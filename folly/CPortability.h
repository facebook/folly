/*
 * Copyright 2015 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef CPORTABILITY_H
#define CPORTABILITY_H

/* These definitions are in a separate file so that they
 * may be included from C- as well as C++-based projects. */

/* Define a convenience macro to test when address sanitizer is being used
 * across the different compilers (e.g. clang, gcc) */
#if defined(__clang__)
# if __has_feature(address_sanitizer)
#  define FOLLY_SANITIZE_ADDRESS 1
# endif
#elif defined (__GNUC__) && \
      (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ >= 5)) && \
      __SANITIZE_ADDRESS__
# define FOLLY_SANITIZE_ADDRESS 1
#endif

/* Define attribute wrapper for function attribute used to disable
 * address sanitizer instrumentation. Unfortunately, this attribute
 * has issues when inlining is used, so disable that as well. */
#ifdef FOLLY_SANITIZE_ADDRESS
# if defined(__clang__)
#  if __has_attribute(__no_address_safety_analysis__)
#   define FOLLY_DISABLE_ADDRESS_SANITIZER \
      __attribute__((__no_address_safety_analysis__, __noinline__))
#  elif __has_attribute(__no_sanitize_address__)
#   define FOLLY_DISABLE_ADDRESS_SANITIZER \
      __attribute__((__no_sanitize_address__, __noinline__))
#  endif
# elif defined(__GNUC__)
#  define FOLLY_DISABLE_ADDRESS_SANITIZER \
     __attribute__((__no_address_safety_analysis__, __noinline__))
# endif
#endif
#ifndef FOLLY_DISABLE_ADDRESS_SANITIZER
# define FOLLY_DISABLE_ADDRESS_SANITIZER
#endif

#ifdef _MSC_VER

#ifndef __STDC__
#define __STDC__ 1
#include <io.h>
#undef __STDC__
#else
#include <io.h>
#endif

#include <folly/WindowsPortability.h>

#include <assert.h>
#include <direct.h>
#include <intrin.h>
#include <inttypes.h>
#include <malloc.h>
#include <math.h>
#include <process.h>
#include <sal.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <WinSock2.h>
#include <sys/stat.h>

#include <pthread.h>

#ifdef __cplusplus
extern "C" {
#endif

// Some permission constants for stat.
#define S_IXUSR 0
#define S_IWUSR _S_IWRITE
#define S_IRUSR _S_IREAD
// No group/other permisions so default to user.
#define S_IXGRP S_IXUSR
#define S_IWGRP S_IWUSR
#define S_IRGRP S_IRUSR
#define S_IXOTH S_IXUSR
#define S_IWOTH S_IWUSR
#define S_IROTH S_IRUSR


void openlog(const char*, int, int);
void closelog();
void syslog(int, const char*, ...);

#define SIGCHLD 0
// We use SIGILL as SIGALRM, as SIGILL is
// never generated by windows.
#define SIGALRM SIGILL
// All 5 of these are invalid signal IDs.
#define SIGVTALRM 26
#define SIGPROF 27
#define SIGKILL 28
#define SIGUSR1 29
#define SIGHUP 30

unsigned int alarm(unsigned int seconds);
char* asctime_r(const tm* tm, _Out_writes_z_(64) char* buf);
void bzero(void* s, size_t n);

#define DT_UNKNOWN 0
#define DT_DIR     1
#define DT_REG     2
#define DT_LNK     3
struct dirent {
  unsigned char d_type;
  char* d_name;
};

struct DIR {
  dirent dir;
  HANDLE hand;
  int cnt;
  char name[MAX_PATH * 3];
};

int closedir(DIR* dir);
char* ctime_r(const time_t* t, char* buf);
char* dirname(char* path);
int dprintf(
  int fd,
  _Printf_format_string_ const char *fmt,
  ...);
int finite(double d);
int getgid();
pid_t getppid();

typedef size_t rlim_t;
struct rlimit {
  rlim_t rlim_cur;
  rlim_t rlim_max;
};
#define RLIMIT_CORE 0
#define RLIMIT_NOFILE 0
#define RLIMIT_DATA 0
#define	RLIMIT_STACK 3
#define RLIM_INFINITY SIZE_MAX
int getrlimit(int type, rlimit* dst);

struct rusage {
  timeval ru_utime;
  timeval ru_stime;
  long ru_maxrss;
  long ru_ixrss;
  long ru_idrss;
  long ru_isrss;
  long ru_minflt;
  long ru_majflt;
  long ru_nswap;
  long ru_inblock;
  long ru_oublock;
  long ru_msgsnd;
  long ru_msgrcv;
  long ru_nsignals;
  long ru_nvcsw;
  long ru_nivcsw;
};

#define RUSAGE_SELF 0
#define RUSAGE_CHILDREN 0
#define RUSAGE_THREAD 0
int getrusage(int who, rusage* usage);

#define POSIX_WIN_FT_OFFSET 116444736000000000ULL
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};
int gettimeofday(timeval* tv, timezone*);

int getuid();
tm* gmtime_r(const time_t* t, tm* res);
int kill(pid_t p, int sig);

#define TM_YEAR_BASE (1900)
tm* localtime_r(const time_t* t, tm* o);

#define MADV_DONTNEED 0
#define MADV_SEQUENTIAL 0
int madvise(const void* addr, size_t len, int advise);
size_t malloc_usable_size(void* addr);
void* memmem(const void* haystack, size_t hlen, const void* needle, size_t nlen);
void* memrchr(const void* s, int c, size_t n);
#ifdef __cplusplus
// This has to be in a namespace to allow overloading.
namespace {
  int mkdir(const char* fn, int mode);
}
#endif
int mlock(const void* addr, size_t len);

#define MAP_ANONYMOUS 1
#define MAP_ANON MAP_ANONYMOUS
#define MAP_SHARED 2
#define MAP_PRIVATE 4
#define MAP_POPULATE 8
#define MAP_NORESERVE 16
#define MAP_FIXED 32

#define MAP_FAILED ((void*)-1)

#define PROT_NONE 0
#define PROT_READ 1
#define PROT_WRITE 2
#define PROT_EXEC 4
void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);

int mprotect(void* addr, size_t size, int prot);
int munlock(const void* addr, size_t length);
int munmap(void* addr, size_t length);
int nanosleep(const struct timespec* request, struct timespec* remain);
DIR* opendir(const char* name);
int pclose(FILE* f);
FILE* popen(const char* name, const char* mode);
int posix_memalign(void** memptr, size_t alignment, size_t size);
dirent* readdir(DIR* dir);
int readdir_r(DIR* dir, dirent* buf, dirent** ent);
void rewinddir(DIR* dir);
void* sbrk(intptr_t i);
void setbuffer(FILE* f, char* buf, size_t size);
int setrlimit(int type, rlimit* src);
unsigned int sleep(unsigned int seconds);
int strcasecmp(const char* a, const char* b);
char* strcasestr(const char* a, const char* b);
int strncasecmp(const char* a, const char* b, size_t c);
char* strndup(const char* a, size_t len);
const char* strsignal(int signal);
char* strtok_r(char* str, char const* delim, char** ctx);

#define SYS_gettid 1
pid_t syscall(int num, ...);

#define _SC_PAGESIZE 1
#define _SC_PAGE_SIZE _SC_PAGESIZE
#define _SC_NPROCESSORS_ONLN 2
#define _SC_NPROCESSORS_CONF 2
size_t sysconf(int tp);

void timersub(timeval* a, timeval* b, timeval* res);
int usleep(unsigned int ms);

struct utsname {
  char* sysname;
  char* nodename;
  char* release;
  char* version;
  char* machine;

  // So that we don't go leaking
  // memory, we use an internal
  // buffer instead.
  char _internal_ver[128];
};
int uname(utsname* buf);
int vasprintf(char** dest, const char* format, va_list ap);

// Next up, some builtin implementations done to make porting more sane.
// If C++ is being compiled, use a version with additional optional parameters
// to make the functions constexpr evaluatable.

#ifdef __cplusplus
inline int __builtin_clz(unsigned int x, unsigned long index = 0) {
  return (int)(_BitScanReverse(&index, (unsigned long)x) ? 31 - index : 32);
}
inline int __builtin_clzl(unsigned long x) { return __builtin_clz((unsigned int)x); }
inline int __builtin_clzll(unsigned long long x, unsigned long index = 0) {
  return (int)(_BitScanReverse64(&index, x) ? 63 - index : 64);
}
#else
inline int __builtin_clz(unsigned int x) {
  unsigned long index;
  return (int)(_BitScanReverse(&index, (unsigned long)x) ? 31 - index : 32);
}
inline int __builtin_clzl(unsigned long x) { return __builtin_clz((unsigned int)x); }
inline int __builtin_clzll(unsigned long long x) {
  unsigned long index;
  return (int)(_BitScanReverse64(&index, x) ? 63 - index : 64);
}
#endif

#ifdef __cplusplus
inline int __builtin_ffs(int x, unsigned long index = 0) {
  return (int)(_BitScanForward(&index, (unsigned long)x) ? index : 0);
}
inline int __builtin_ffsl(long x) { return __builtin_ffs((int)x); }
inline int __builtin_ffsll(long long x, unsigned long index = 0) {
  return (int)(_BitScanForward64(&index, (unsigned long long)x) ? index : 0);
}
#else
inline int __builtin_ffs(int x) {
  unsigned long index;
  return (int)(_BitScanForward(&index, (unsigned long)x) ? index : 0);
}
inline int __builtin_ffsl(long x) { return __builtin_ffs((int)x); }
inline int __builtin_ffsll(long long x) {
  unsigned long index;
  return (int)(_BitScanForward64(&index, (unsigned long long)x) ? index : 0);
}
#endif

inline int __builtin_popcountll(unsigned long long x) {
  return (int)__popcnt64(x);
}

inline void* __builtin_return_address(unsigned int frame) {
  // I really hope frame is zero...
  assert(frame == 0);
  return _ReturnAddress();
}

#ifdef __cplusplus
}
#endif

#else
#include <dirent.h>
#include <libgen.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#include <sys/time.h>
#endif

#endif
