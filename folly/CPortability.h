/*
 * Copyright 2015 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef CPORTABILITY_H
#define CPORTABILITY_H

/* These definitions are in a separate file so that they
 * may be included from C- as well as C++-based projects. */

/* Define a convenience macro to test when address sanitizer is being used
 * across the different compilers (e.g. clang, gcc) */
#if defined(__clang__)
# if __has_feature(address_sanitizer)
#  define FOLLY_SANITIZE_ADDRESS 1
# endif
#elif defined (__GNUC__) && \
      (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ >= 5)) && \
      __SANITIZE_ADDRESS__
# define FOLLY_SANITIZE_ADDRESS 1
#endif

/* Define attribute wrapper for function attribute used to disable
 * address sanitizer instrumentation. Unfortunately, this attribute
 * has issues when inlining is used, so disable that as well. */
#ifdef FOLLY_SANITIZE_ADDRESS
# if defined(__clang__)
#  if __has_attribute(__no_address_safety_analysis__)
#   define FOLLY_DISABLE_ADDRESS_SANITIZER \
      __attribute__((__no_address_safety_analysis__, __noinline__))
#  elif __has_attribute(__no_sanitize_address__)
#   define FOLLY_DISABLE_ADDRESS_SANITIZER \
      __attribute__((__no_sanitize_address__, __noinline__))
#  endif
# elif defined(__GNUC__)
#  define FOLLY_DISABLE_ADDRESS_SANITIZER \
     __attribute__((__no_address_safety_analysis__, __noinline__))
# endif
#endif
#ifndef FOLLY_DISABLE_ADDRESS_SANITIZER
# define FOLLY_DISABLE_ADDRESS_SANITIZER
#endif


#ifdef _MSC_VER
#include <sys/stat.h>
#endif


#ifdef _MSC_VER

#ifndef __STDC__
#define __STDC__ 1
#include <io.h>
#undef __STDC__
#else
#include <io.h>
#endif

#include <assert.h>
#include <direct.h>
#include <intrin.h>
#include <malloc.h>
#include <math.h>
#include <sal.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <Windows.h>
#include <WinSock2.h>
#include <sys/stat.h>

#include <pthread.h>
#include <pthread_clock.h>

// Some permission constants for stat.
#define S_IXUSR 0
#define S_IWUSR _S_IWRITE
#define S_IRUSR _S_IREAD
// No group/other permisions so default to user.
#define S_IXGRP S_IXUSR
#define S_IWGRP S_IWUSR
#define S_IRGRP S_IRUSR
#define S_IXOTH S_IXUSR
#define S_IWOTH S_IWUSR
#define S_IROTH S_IRUSR


// Do nothing for the system log for now.
inline void openlog(const char*, int, int) {}
inline void closelog() {}
inline void syslog(int, const char*, ...) {}

#define SIGCHLD 0
// We use SIGILL as SIGALRM, as SIGILL is
// never generated by windows.
#define SIGALRM SIGILL
// All 5 of these are invalid signal IDs.
#define SIGVTALRM 26
#define SIGPROF 27
#define SIGKILL 28
#define SIGUSR1 29
#define SIGHUP 30

inline void __stdcall __alarm_callback_func(HWND, UINT, UINT_PTR, DWORD) {
  raise(SIGALRM);
}

inline unsigned int alarm(unsigned int seconds) {
  SetTimer(NULL, 0, (UINT)(seconds * 1000), __alarm_callback_func);
  return 0;
}

inline char* asctime_r(
  const tm* tm,
  _Out_writes_z_(64) char* buf
) {
  char tmpBuf[64];
  if (asctime_s(tmpBuf, sizeof(tmpBuf), tm))
    return NULL;
  return strcpy(buf, tmpBuf);
}

inline void bzero(void* s, size_t n) {
  ZeroMemory(s, n);
}

#define DT_UNKNOWN 0
#define DT_DIR     1
#define DT_REG     2
#define DT_LNK     3
struct dirent {
  unsigned char d_type;
  char* d_name;
};

struct DIR {
  dirent dir;
  HANDLE hand;
  int cnt;
  char name[MAX_PATH * 3];
};

inline int closedir(DIR* dir) {
  if (!FindClose(dir->hand))
    return -1;
  free(dir);
  return 0;
}

inline char* ctime_r(const time_t* t, char* buf) {
  char tmpBuf[64];
  if (ctime_s(tmpBuf, sizeof(tmpBuf), t))
    return NULL;
  return strcpy(buf, tmpBuf);
}

inline char* dirname(char* path) {
  if (path == NULL || !strcmp(path, ""))
    return ".";
  
  size_t len = strlen(path);
  char* pos = strrchr(path, '/');
  if (strrchr(path, '\\') > pos)
    pos = strrchr(path, '\\');
  if (pos == NULL)
    return ".";

  // Final slash with no name.
  if (path + len == pos) {
    *pos = '\0';

    char* pos2 = strrchr(path, '/');
    if (strrchr(path, '\\') > pos2)
      pos2 = strrchr(path, '\\');
    if (pos2 == NULL)
      return ".";

    *pos2 = '\0';
    return path;
  }

  *pos = '\0';
  return path;
}

inline int dprintf(
  int fd,
  _Printf_format_string_ const char *fmt,
  ...
) {
  va_list args;
  va_start(args, fmt);

  int len = vsnprintf(NULL, 0, fmt, args);
  if (len <= 0)
    return -1;
  char* buf = (char*)malloc(len + 1);
  if (vsnprintf(buf, len + 1, fmt, args) == len &&
      _write(fd, buf, len) == len) {
    free(buf);
    va_end(args);
    return len;
  }
  
  free(buf);
  va_end(args);
  return -1;
}

inline int finite(double d) {
  return isfinite(d) ? 1 : 0;
}

inline int getgid() {
  return 0;
}

#ifndef _PID_T_
typedef uintptr_t pid_t;
#define _PID_T_     1
#endif
// No major need to implement this, and getting a non-potentially
// stale ID on windows is a bit involved.
inline pid_t getppid() {
  return 0;
}

typedef size_t rlim_t;
struct rlimit {
  rlim_t rlim_cur;
  rlim_t rlim_max;
};
#define RLIMIT_CORE 0
#define RLIMIT_NOFILE 0
#define RLIMIT_DATA 0
#define	RLIMIT_STACK 3
#define RLIM_INFINITY SIZE_MAX

inline int getrlimit(int type, rlimit* dst) {
  if (type == RLIMIT_STACK) {
    NT_TIB* tib = (NT_TIB*)NtCurrentTeb();
    dst->rlim_max = dst->rlim_cur = (size_t)tib->StackBase - (size_t)tib->StackLimit;
    return 0;
  }
  return -1;
}

struct rusage {
  timeval ru_utime;
  timeval ru_stime;
  long ru_maxrss;
  long ru_ixrss;
  long ru_idrss;
  long ru_isrss;
  long ru_minflt;
  long ru_majflt;
  long ru_nswap;
  long ru_inblock;
  long ru_oublock;
  long ru_msgsnd;
  long ru_msgrcv;
  long ru_nsignals;
  long ru_nvcsw;
  long ru_nivcsw;
};

#define RUSAGE_SELF 0
#define RUSAGE_CHILDREN 0
#define RUSAGE_THREAD 0
inline int getrusage(int who, rusage* usage) {
  ZeroMemory(usage, sizeof(rusage));
  return 0;
}

#define POSIX_WIN_FT_OFFSET 116444736000000000ULL
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};
inline int gettimeofday(timeval* tv, timezone*) {
  FILETIME ft;
  if (tv) {
    GetSystemTimeAsFileTime(&ft);
    uint64_t ns = *(uint64_t*)&ft;
    tv->tv_usec = (long)((ns / 10ULL) % 1000000ULL);
    tv->tv_sec = (long)((ns - POSIX_WIN_FT_OFFSET) / 10000000ULL);
  }
  return 0;
}

inline int getuid() {
  return 0;
}

inline tm* gmtime_r(const time_t* t, tm* res) {
  if (!gmtime_s(res, t))
    return res;
  return NULL;
}

inline int kill(pid_t p, int sig) {
  HANDLE h = OpenProcess(PROCESS_TERMINATE, FALSE, (DWORD)p);
  if (!TerminateProcess(h, (UINT)-1))
    return -1;
  return 0;
}

#define TM_YEAR_BASE (1900)
inline tm* localtime_r(const time_t* t, tm* o) {
  tm* tmp = localtime(t);
  if (tmp) {
    *o = *tmp;
    return o;
  }
  return NULL;
}

#define MADV_DONTNEED 0
#define MADV_SEQUENTIAL 0
inline int madvise(const void* addr, size_t len, int advise) {
  // We do nothing at all.
  // Could probably implement dontneed via VirtualAlloc
  // with the MEM_RESET and MEM_RESET_UNDO flags. 
  return 0;
}

inline size_t malloc_usable_size(void* addr) {
  return _msize(addr);
}

inline void* memmem(const void* haystack, size_t hlen, const void* needle, size_t nlen) {
  int needle_first;
  const char* p = (const char*)haystack;
  size_t plen = hlen;

  if (!nlen)
    return NULL;

  needle_first = *(unsigned char*)needle;

  while (plen >= nlen && (p = (const char*)memchr(p, needle_first, plen - nlen + 1)))
  {
    if (!memcmp(p, needle, nlen))
      return (void *)p;

    p++;
    plen = hlen - (p - (const char*)haystack);
  }

  return NULL;
}

inline void* memrchr(const void* s, int c, size_t n) {
  const unsigned char* p = ((const unsigned char*)s) + n;
  while (p >= (const unsigned char*)s) {
    if (*p == (unsigned char)c) {
      return (void*)p;
    }
    p--;
  }
  return NULL;
}

#ifdef __cplusplus
inline int mkdir(const char* fn, int mode) {
  return _mkdir(fn);
}
#endif

inline int mlock(const void* addr, size_t len) {
  if (!VirtualLock((void*)addr, len))
    return -1;
  return 0;
}

#define MAP_ANONYMOUS 1
#define MAP_ANON MAP_ANONYMOUS
#define MAP_SHARED 2
#define MAP_PRIVATE 4
#define MAP_POPULATE 8
#define MAP_NORESERVE 16
#define MAP_FIXED 32

#define MAP_FAILED ((void*)-1)

#define PROT_NONE 0
#define PROT_READ 1
#define PROT_WRITE 2
#define PROT_EXEC 4

inline void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset) {
  // Make sure it's something we support first.

  // Might be reasonable to ignore addr entirely.
  if (addr != NULL)
    return MAP_FAILED;
  // Don't currently support fixed mapping.
  if (flags & MAP_FIXED)
    return MAP_FAILED;
  // No Anon shared.
  if ((flags & (MAP_ANONYMOUS | MAP_SHARED)) == (MAP_ANONYMOUS | MAP_SHARED))
    return MAP_FAILED;
  // No private copy on write.
  if ((flags & MAP_PRIVATE) == MAP_PRIVATE && fd != -1)
    return MAP_FAILED;

  // Map isn't anon, must be file backed.
  if (!(flags & MAP_ANONYMOUS) && fd == -1)
    return MAP_FAILED;

  DWORD newProt;
  if (prot == PROT_NONE)
    newProt = PAGE_NOACCESS;
  else if (prot == PROT_READ)
    newProt = PAGE_READONLY;
  else if (prot == PROT_EXEC)
    newProt = PAGE_EXECUTE;
  else if (prot == (PROT_READ | PROT_EXEC))
    newProt = PAGE_EXECUTE_READ;
  else if (prot == (PROT_READ | PROT_WRITE))
    newProt = PAGE_READWRITE;
  else if (prot == (PROT_READ | PROT_WRITE | PROT_EXEC))
    newProt = PAGE_EXECUTE_READWRITE;
  else
    return MAP_FAILED;

  void* ret;
  if (!(flags & MAP_ANONYMOUS) || (flags & MAP_SHARED)) {
    HANDLE h = INVALID_HANDLE_VALUE;
    if (!(flags & MAP_ANONYMOUS))
      h = (HANDLE)_get_osfhandle(fd);

    HANDLE fmh = CreateFileMapping(h, nullptr, prot | SEC_COMMIT | SEC_RESERVE,
      (DWORD)((length >> 32) & 0xFFFFFFFF), (DWORD)(length & 0xFFFFFFFF), nullptr);
    // Depending on specifics, off_t may be 32-bit, so get MSVC to be quiet about
    // it.
#pragma warning(push)
#pragma warning(disable: 4293)
    ret = MapViewOfFile(fmh, FILE_MAP_ALL_ACCESS, 
      (DWORD)((offset >> 32) & 0xFFFFFFFF), (DWORD)(offset & 0xFFFFFFFF), 0);
#pragma warning(pop)
    CloseHandle(fmh);
  }
  else {
    ret = VirtualAlloc(NULL, length, MEM_COMMIT | MEM_RESERVE, prot);
  }
  
  // TODO: Could technically implement MAP_POPULATE via PrefetchVirtualMemory
  //       Should also see about implementing MAP_NORESERVE
  return ret;
}

inline int mprotect(void* addr, size_t size, int prot) {
  DWORD newProt;
  if (prot == PROT_NONE)
    newProt = PAGE_NOACCESS;
  else if (prot == PROT_READ)
    newProt = PAGE_READONLY;
  else if (prot == PROT_EXEC)
    newProt = PAGE_EXECUTE;
  else if (prot == (PROT_READ | PROT_EXEC))
    newProt = PAGE_EXECUTE_READ;
  else if (prot == (PROT_READ | PROT_WRITE))
    newProt = PAGE_READWRITE;
  else if (prot == (PROT_READ | PROT_WRITE | PROT_EXEC))
    newProt = PAGE_EXECUTE_READWRITE;
  else
    return -1;

  DWORD oldProt;
  BOOL res = VirtualProtect(addr, size, newProt, &oldProt);
  if (!res)
    return -1;
  return 0;
}

inline int munlock(const void* addr, size_t length) {
  if (!VirtualUnlock((void*)addr, length))
    return -1;
  return 0;
}

inline int munmap(void* addr, size_t length) {
  // Try to unmap it as a file, otherwise VirtualFree.
  if (!UnmapViewOfFile(addr)) {
    if (!VirtualFree(addr, length, MEM_RELEASE))
      return -1;
    return 0;
  }
  return 0;
}

inline DIR* opendir(const char* name) {
  wchar_t pattern[MAX_PATH + 2];
  size_t len;

  if (mbstowcs_s(&len, pattern, MAX_PATH, name, MAX_PATH - 2))
    return NULL;

  if (len && pattern[len - 1] != '/' && pattern[len - 1] != '\\')
    pattern[len++] = '\\';
  pattern[len++] = '*';
  pattern[len] = 0;

  WIN32_FIND_DATAW fdata;
  HANDLE h = FindFirstFileW(pattern, &fdata);
  if (h == INVALID_HANDLE_VALUE)
    return NULL;

  DIR* dir = (DIR*)malloc(sizeof(DIR));
  dir->dir.d_name = dir->name;
  dir->hand = h;
  dir->cnt = 0;
  wcstombs(dir->name, fdata.cFileName, MAX_PATH * 3);

  if (fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    dir->dir.d_type = DT_DIR;
  else
    dir->dir.d_type = DT_REG;

  return (DIR*)dir;
}

inline int pclose(FILE* f) {
  return _pclose(f);
}

inline FILE* popen(const char* name, const char* mode) {
  return _popen(name, mode);
}

inline int posix_memalign(void** memptr, size_t alignment, size_t size) {
  void* ret = _aligned_malloc(size, alignment);
  if (ret == nullptr)
    return -1;
  *memptr = ret;
  return 0;
}

inline dirent* readdir(DIR* dir) {
  if (dir->cnt) {
    WIN32_FIND_DATAW fdata;
    if (!FindNextFileW(dir->hand, &fdata))
      return NULL;

    wcstombs(dir->name, fdata.cFileName, MAX_PATH * 3);
    if (fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
      dir->dir.d_type = DT_DIR;
    else
      dir->dir.d_type = DT_REG;
  }

  dir->cnt++;
  return &dir->dir;
}

inline int readdir_r(DIR* dir, dirent* buf, dirent** ent) {
  if (dir->cnt) {
    WIN32_FIND_DATAW fdata;
    if (!FindNextFileW(dir->hand, &fdata)) {
      *ent = NULL;
      return 0;
    }

    wcstombs(dir->name, fdata.cFileName, MAX_PATH * 3);
    if (fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
      dir->dir.d_type = DT_DIR;
    else
      dir->dir.d_type = DT_REG;
  }

  dir->cnt++;
  memcpy(buf, &dir->dir, sizeof(dirent));
  *ent = buf;
  return 0;
}

inline void rewinddir(DIR* dir) {
  FindClose(dir->hand);

  WIN32_FIND_DATA fdata;
  HANDLE h = FindFirstFile(dir->dir.d_name, &fdata);
  dir->hand = h;
  dir->cnt = 0;
  strcpy_s(dir->name, MAX_PATH * 3, fdata.cFileName);

  if (fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    dir->dir.d_type = DT_DIR;
  else
    dir->dir.d_type = DT_REG;
}

inline void* sbrk(intptr_t i) { return (void*)-1; }

inline void setbuffer(FILE* f, char* buf, size_t size) {
  setvbuf(f, buf, _IOFBF, size);
}

inline int setrlimit(int type, rlimit* src) {
  // Do nothing for setting them for now
  return 0;
}

inline unsigned int sleep(unsigned int seconds) {
  Sleep((DWORD)(seconds * 1000));
  return 0;
}

inline int strcasecmp(const char* a, const char* b) {
  return _stricmp(a, b);
}

inline char* strcasestr(const char* a, const char* b) {
  char* a2 = _strlwr(strdup(a));
  char* b2 = _strlwr(strdup(b));
  char* tmp = strstr(a2, b2);
  if (!tmp) {
    free(a2);
    free(b2);
    return NULL;
  }
  char* ret = (char*)a + (tmp - a2);
  free(a2);
  free(b2);
  return ret;
}

inline int strncasecmp(const char* a, const char* b, size_t c) {
  return _strnicmp(a, b, c);
}

inline char* strndup(const char* a, size_t len) {
  char* buf = (char*)calloc(len + 1, sizeof(char));
  strncpy(buf, a, len);
  return buf;
}

inline const char* strsignal(int signal) {
#define SIG_CASE(sig) case sig: return "sig"
  switch (signal) {
    SIG_CASE(SIGINT);
    SIG_CASE(SIGILL);
    SIG_CASE(SIGABRT);
    SIG_CASE(SIGFPE);
    SIG_CASE(SIGSEGV);
    SIG_CASE(SIGTERM);
    SIG_CASE(SIGCHLD);
    SIG_CASE(SIGVTALRM);
    SIG_CASE(SIGPROF);
    default: return "";
  }
#undef SIG_CASE
}

inline char* strtok_r(char* str, char const* delim, char** ctx) {
  return strtok_s(str, delim, ctx);
}

#define SYS_gettid 1
inline pid_t syscall(int num, ...) {
  if (num == SYS_gettid) {
    return (pid_t)pthread_self();
  }
  return -1;
}

#define _SC_PAGESIZE 1
#define _SC_PAGE_SIZE _SC_PAGESIZE
#define _SC_NPROCESSORS_ONLN 2
#define _SC_NPROCESSORS_CONF 2
inline size_t sysconf(int tp) {
  switch (tp) {
    case _SC_PAGESIZE: {
      SYSTEM_INFO inf;
      GetSystemInfo(&inf);
      return (size_t)inf.dwPageSize;
    }
    case _SC_NPROCESSORS_ONLN: {
      SYSTEM_INFO inf;
      GetSystemInfo(&inf);
      return (size_t)inf.dwNumberOfProcessors;
    }
    default: return (size_t)-1;
  }
}

inline void timersub(timeval* a, timeval* b, timeval* res) {
  res->tv_sec = a->tv_sec - b->tv_sec;
  res->tv_usec = a->tv_usec - b->tv_usec;
  if (res->tv_usec < 0) {
    res->tv_sec--;
    res->tv_usec += 1000000;
  }
}

inline int usleep(unsigned int ms) {
  Sleep((DWORD)(ms / 1000));
  return 0;
}

struct utsname {
  char* sysname;
  char* nodename;
  char* release;
  char* version;
  char* machine;

  // So that we don't go leaking
  // memory, we use an internal
  // buffer instead.
  char _internal_ver[128];
};

inline int uname(utsname* buf) {
  buf->sysname = "Windows";
  buf->nodename = "";
  buf->machine = "";
  OSVERSIONINFO verInf;
  verInf.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
#pragma warning(push)
#pragma warning(disable: 4996)
  // GetVersionEx is deprecated, but they provided no
  // replacement for our use-case.
  GetVersionEx(&verInf);
#pragma warning(pop)
  memcpy(buf->_internal_ver, verInf.szCSDVersion, 128);
  buf->release = buf->version = buf->_internal_ver;
  return 0;
}

inline int vasprintf(char** dest, const char* format, va_list ap) {
  int len = vsnprintf(NULL, 0, format, ap);
  if (len <= 0)
    return -1;
  char* buf = *dest = (char*)malloc(len + 1);
  if (vsnprintf(buf, len + 1, format, ap) == len)
    return len;
  free(buf);
  return -1;
}

// Next up, some builtin implementations done to make porting more sane.
// If C++ is being compiled, use a version with additional optional parameters
// to make the functions constexpr evaluatable.

#ifdef __cplusplus
inline int __builtin_clz(unsigned int x, unsigned long index = 0) {
  return (int)(_BitScanReverse(&index, (unsigned long)x) ? 31 - index : 32);
}
inline int __builtin_clzl(unsigned long x) { return __builtin_clz((unsigned int)x); }
inline int __builtin_clzll(unsigned long long x, unsigned long index = 0) {
  return (int)(_BitScanReverse64(&index, x) ? 63 - index : 64);
}
#else
inline int __builtin_clz(unsigned int x) {
  unsigned long index;
  return (int)(_BitScanReverse(&index, (unsigned long)x) ? 31 - index : 32);
}
inline int __builtin_clzl(unsigned long x) { return __builtin_clz((unsigned int)x); }
inline int __builtin_clzll(unsigned long long x) {
  unsigned long index;
  return (int)(_BitScanReverse64(&index, x) ? 63 - index : 64);
}
#endif

#ifdef __cplusplus
inline int __builtin_ffs(int x, unsigned long index = 0) {
  return (int)(_BitScanForward(&index, (unsigned long)x) ? index : 0);
}
inline int __builtin_ffsl(long x) { return __builtin_ffs((int)x); }
inline int __builtin_ffsll(long long x, unsigned long index = 0) {
  return (int)(_BitScanForward64(&index, (unsigned long long)x) ? index : 0);
}
#else
inline int __builtin_ffs(int x) {
  unsigned long index;
  return (int)(_BitScanForward(&index, (unsigned long)x) ? index : 0);
}
inline int __builtin_ffsl(long x) { return __builtin_ffs((int)x); }
inline int __builtin_ffsll(long long x) {
  unsigned long index;
  return (int)(_BitScanForward64(&index, (unsigned long long)x) ? index : 0);
}
#endif

inline int __builtin_popcountll(unsigned long long x) {
  return (int)__popcnt64(x);
}

inline void* __builtin_return_address(unsigned int frame) {
  // I really hope frame is zero...
  assert(frame == 0);
  return _ReturnAddress();
}

#else
#include <libgen.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#endif

#endif
